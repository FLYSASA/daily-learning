# koma-ui
此篇文章主要用于koma-ui搭建过程中的整体复盘。

### 1. 初始化项目
```bash
git init 
git add .
git commit -m 'init'
git remote add origin 'xxx' // xxx为项目在github上的地址
git push origin master
```

### 2. 引入并使用vue
```
npm i vue  // 项目下安装vue
```

#### ① 直接引入
```js
// index.html
<body>
  <div id="app">
    <k-button>按钮</k-button>
  </div>
</body>
<script src="./node_modules/vue/dist/vue.min.js"></script>
<script src="./button.js"></script>
<script>
  new Vue({
    el: '#app'
  })
</script>

// button.js
Vue.component('k-button', {
  template: '<button class="koma-button">按钮</button>'
})
```
这样虽然可以直接使用vue，但是js引入的方式还是很不方便。

#### ② 使用构建工具使用vue
vue的独特之处是可以使用vue单文件的形式去写组件，这需要构建工具做打包编译处理，这里引入 **parcel**。
```
npm i parcel-bundler -D
```
```js
// 代码重构
// index.html
<body>
  <div id="app">
    <k-button>按钮</k-button>
  </div>
</body>
<script src="./src/app.js"></script>

// app.js
import Vue from 'vue';
import Button from 'button.vue'

Vue.component('k-button', Button)

new Vue({
  el: '#app'
})

// button.vue
<template>
  <div>
    <button class="koma-button">按钮</button>
  </div>
</template>
```
运行index.html:
```
// 命令行执行
./node_modules/.bin/parcel index.html
或者
npx parcel index.html --no-cache // --no-cache不走缓存
```
到这里就可以正常预览到我们写的按钮了。


---
### 3. Icon 组件
icon组件比较简单，主要是使用了 iconfont symbol引入的方式。
```
<svg class="k-icon">
  <use :xlink:href="`#i-${name}`"></use>
</svg> 
```

- 项目里并没有使用iconfont的在线链接，而是本地静态引入了svg内容，以保证项目的稳定性。
---
### 4. Button 组件
核心思路：
> button组件主要是使用了 `vue slot`。大部分是css相关的，使用`flex`布局, 根据`iconPosition`的改变，来调整元素的`order`。

代码层面上，在`k-button-group`中需要校验其子元素是否为 `button` 元素。
```js
// this.$el.children 是HTMLCollection元素集合，是一个数组
for( let node of this.$el.children) {
  if(node.NodeName.toLowerCase() !== 'button') {
    console.warn(`k-button-group 的子元素应该全是 k-button, 但是你写的是 ${ node.nodeName }`)
  }
}
```

**for...of 是用来遍历数组的（es6引入的新特性）， for...in是用来遍历对象的。**

---
### 5. Grid 组件
核心思路：
> row组件代表一行，采用最基础的24分栏。 内部的col组件通过设置span栏数，来决定自己的宽度。

grid组件的重要属性实现：
- row:
  + `gutter`: 栏之间的间隔。gutter 会由父传给子，然后决定子的左右`padding`值为`gutter`的一半，父的左右`margin`为`﹣1/2gutter`保证整体不会超出容器。
  + `align`: 对齐方式。row是以flex布局的，align的`left, right, center`对应`flex-start, flex-end, flex-center`。

- col:
  + `span`: col占据的栏数。这个决定了其宽度的百分比。
  + `offset`: col偏移多少栏。这个决定了当前栏左margin的宽度百分比。
  + `ipad、narrowPc、pc、widePc`: 这几个可以设置对应不同大小屏占据的分栏数。实现原理就是通过传入不同的属性，来追加不同的class。然后再在不同的class下写不同的样式。越大屏的尺寸样式应该越写在下面，为了不被其他尺寸样式覆盖。

  ```js
  // 大致代码思路
  // html
  <div class="koma-col" :class="colClass"></div>

  // js
  computed: {
    colClass() {
      const { span, offset, ipad, narrowPc, pc, widePc } = this
      return [
        this.createClass({span, offset}),
        this.createClass(ipad, 'ipad-'),
        this.createClass(narrowPc, 'narrow-pc-'),
        this.createClass(pc, 'pc-'),
        this.createClass(widePc, 'wide-pc-'),
      ]
    }
  },
  methods: {
    createClass(obj, str) {
      if(!obj) { return }
      let arr = []
      if(obj.span) {
        arr.push(`col-${str}${obj.span}`)
      }
      if(obj.offset) {
        arr.push(`offset-${str}${obj.offset}`)
      }
      return arr;
    },
  }
  
  // css
  @media (min-width: 577px) {
    .koma-col {
      @class: col-ipad-;
      .col-loop(@n) when (@n>0){
        &.@{class}@{n}{
            width: @n/24*100%;
        }
        .col-loop((@n)-1);
      }
      .col-loop(24);

      @offset: offset-ipad-;
      .offset-loop(@n) when (@n>0){
        &.@{offset}@{n}{
            margin-left: @n/24*100%;
        }
        .offset-loop((@n)-1);
      }
      .offset-loop(24)
    }
  }
  ```
---
  ### 6. Layout 组件
  核心思路：
> layout组件里如果有 `sider` 就直接`flex-direction: row`. 没有就是 `flex-direction: column`。

```js
<div class="koma-layout" :class="layoutClass">
  <slot></slot>
</div>

export default {
  data() {
    return {
      layoutClass: {
        hasSider: false
      }
    }
  },
  mounted () {
    // 关键点在于判断layout组件下有没有sider组件
    this.$children.forEach((vm) => {
      if(vm.$options.name === 'KomaSider') {
        this.layoutClass.hasSider = true
      }
    })
  }
}
```

---
### 7. Input组件
核心思路：
> input组件主要是实现 v-model 双向绑定，它其实就是一个语法糖，它利用了名为 `value` 的 `prop`，和名为 `input` 的事件。

```
// v-model实现
```
