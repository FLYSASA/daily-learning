# koma-ui
此篇文章主要用于koma-ui搭建过程中的整体复盘。

### 1. 初始化项目
```bash
git init 
git add .
git commit -m 'init'
git remote add origin 'xxx' // xxx为项目在github上的地址
git push origin master
```

### 2. 引入并使用vue
```
npm i vue  // 项目下安装vue
```

#### ① 直接引入
```js
// index.html
<body>
  <div id="app">
    <k-button>按钮</k-button>
  </div>
</body>
<script src="./node_modules/vue/dist/vue.min.js"></script>
<script src="./button.js"></script>
<script>
  new Vue({
    el: '#app'
  })
</script>

// button.js
Vue.component('k-button', {
  template: '<button class="koma-button">按钮</button>'
})
```
这样虽然可以直接使用vue，但是js引入的方式还是很不方便。

#### ② 使用构建工具使用vue
vue的独特之处是可以使用vue单文件的形式去写组件，这需要构建工具做打包编译处理，这里引入 **parcel**。
```
npm i parcel-bundler -D
```
```js
// 代码重构
// index.html
<body>
  <div id="app">
    <k-button>按钮</k-button>
  </div>
</body>
<script src="./src/app.js"></script>

// app.js
import Vue from 'vue';
import Button from 'button.vue'

Vue.component('k-button', Button)

new Vue({
  el: '#app'
})

// button.vue
<template>
  <div>
    <button class="koma-button">按钮</button>
  </div>
</template>
```

运行index.html:
```bash
// 命令行执行
./node_modules/.bin/parcel index.html
或者
npx parcel index.html --no-cache // --no-cache不走缓存
```
到这里就可以正常预览到我们写的按钮了。


---
### 3. Icon 组件
icon组件比较简单，主要是使用了 iconfont symbol引入的方式。
```
<svg class="k-icon">
  <use :xlink:href="`#i-${name}`"></use>
</svg> 
```

- 项目里并没有使用iconfont的在线链接，而是本地静态引入了svg内容，以保证项目的稳定性。
---
### 4. Button 组件
核心思路：
> button组件主要是使用了 `vue slot`。大部分是css相关的，使用`flex`布局, 根据`iconPosition`的改变，来调整元素的`order`。

代码层面上，在`k-button-group`中需要校验其子元素是否为 `button` 元素。
```js
// this.$el.children 是HTMLCollection元素集合，是一个数组
for( let node of this.$el.children) {
  if(node.NodeName.toLowerCase() !== 'button') {
    console.warn(`k-button-group 的子元素应该全是 k-button, 但是你写的是 ${ node.nodeName }`)
  }
}
```

**for...of 是用来遍历数组的（es6引入的新特性）， for...in是用来遍历对象的。**

---
### 5. Grid 组件
核心思路：
> row组件代表一行，采用最基础的24分栏。 内部的col组件通过设置span栏数，来决定自己的宽度。

grid组件的重要属性实现：
- row:
  + `gutter`: 栏之间的间隔。gutter 会由父传给子，然后决定子的左右`padding`值为`gutter`的一半，父的左右`margin`为`﹣1/2gutter`保证整体不会超出容器。
  + `align`: 对齐方式。row是以flex布局的，align的`left, right, center`对应`flex-start, flex-end, flex-center`。

- col:
  + `span`: col占据的栏数。这个决定了其宽度的百分比。
  + `offset`: col偏移多少栏。这个决定了当前栏左margin的宽度百分比。
  + `ipad、narrowPc、pc、widePc`: 这几个可以设置对应不同大小屏占据的分栏数。实现原理就是通过传入不同的属性，来追加不同的class。然后再在不同的class下写不同的样式。越大屏的尺寸样式应该越写在下面，为了不被其他尺寸样式覆盖。

  ```js
  // 大致代码思路
  // html
  <div class="koma-col" :class="colClass"></div>

  // js
  computed: {
    colClass() {
      const { span, offset, ipad, narrowPc, pc, widePc } = this
      return [
        this.createClass({span, offset}),
        this.createClass(ipad, 'ipad-'),
        this.createClass(narrowPc, 'narrow-pc-'),
        this.createClass(pc, 'pc-'),
        this.createClass(widePc, 'wide-pc-'),
      ]
    }
  },
  methods: {
    createClass(obj, str) {
      if(!obj) { return }
      let arr = []
      if(obj.span) {
        arr.push(`col-${str}${obj.span}`)
      }
      if(obj.offset) {
        arr.push(`offset-${str}${obj.offset}`)
      }
      return arr;
    },
  }
  
  // css
  @media (min-width: 577px) {
    .koma-col {
      @class: col-ipad-;
      .col-loop(@n) when (@n>0){
        &.@{class}@{n}{
            width: @n/24*100%;
        }
        .col-loop((@n)-1);
      }
      .col-loop(24);

      @offset: offset-ipad-;
      .offset-loop(@n) when (@n>0){
        &.@{offset}@{n}{
            margin-left: @n/24*100%;
        }
        .offset-loop((@n)-1);
      }
      .offset-loop(24)
    }
  }
  ```
---
### 6. Layout 组件
  核心思路：
> layout组件里如果有 `sider` 就直接`flex-direction: row`. 没有就是 `flex-direction: column`。

```js
<div class="koma-layout" :class="layoutClass">
  <slot></slot>
</div>

export default {
  data() {
    return {
      layoutClass: {
        hasSider: false
      }
    }
  },
  mounted () {
    // 关键点在于判断layout组件下有没有sider组件
    this.$children.forEach((vm) => {
      if(vm.$options.name === 'KomaSider') {
        this.layoutClass.hasSider = true
      }
    })
  }
}
```

---
### 7. Input组件
核心思路：
> input组件主要是实现 v-model 双向绑定，它其实就是一个语法糖，它利用了名为 `value` 的 `prop`，和名为 `input` 的事件。

```html
// v-model实现
<k-input v-model="value" ></k-input>

// 相当于
<k-input :value="value" @input="value=$event.target.value"></k-input>

// k-input
<input type="text"  :value="value" @input="$emit('input', $event.target.value)"><input>
```

另外一个小知识点是 `v-bind=$attrs` 的用法， 当我们子组件想继承父组件的属性时，但是又不想在props里挨个定义，就可以直接使用 $attrs , 包含了父作用域中不作为 prop 被识别 (且获取) 的 attribute 绑定 (class 和 style 除外)

另外一个类似的是 `v-on=$listeners"`, 包含父作用域中的不含 `.native` 修饰器的 `v-on` 事件监听器。
### 8. Toast组件
toast一般调用方法如： `this.$toast('我知道');`  看起来需要绑定在`vue.protoType` 上。但是直接绑定会有vue风险，如：
```
// 用户引入vue,  此时就应该绑定在 vue2.prototype上
import vue2  from Vue;
```

vue官方提供了插件的方法，支持你对Vue添加全局功能。示例如下：

```js
// 1.创建plugin.js
// plugin要做的事并不复杂，只需要导出一个install方法即可。
export default {
  install(Vue, options) {
    // 这里面就可以添加全局方法、全局指令、全局混入项等等
    Vue.protoType.$toast = function(message, toastOptions) {
      // dosth...
    }
  }
}


// 2. 使用插件
// 可以在一个公共js的地方引入
// common.js

import plugin from './plugin.js'
Vue.use(plugin);    // 用户自己使用Vue调用插件，避免了上面vue指向问题
```

核心思路：
> 1. toast要考虑的是其位置，这里主要在toast div上又包裹一层 wrapper，这个wrapper作用很简单就是 横向定位，这么做的目的在于，因为内部的toast的还有上下的动画效果，由于定位都是使用的transform，如果放在一个div上，会重置掉横向定位。
> 2. toast需要考虑唯一性，因为用户可能重复点击，会导致多个toast同时出现，所以就需要每次清除掉上次出现的toast。


```js
// plugin.js
import Toast from './components/toast';

let currentToast;
export default {
  install(Vue, options) {
    // 全局调用的实例方法
    Vue.prototype.$toast = function (message, toastOptions) {
      // 如果存在，就清掉
      if(currentToast) {
        currentToast.close();
      }
      currentToast = createToast({
        Vue,
        message,
        propsData: toastOptions,
        // 插入一个回调，监听toast组件的close事件，然后将currentToast清掉
        onClose: ()=>{
          currentToast = null;
        }
      })
    }
  }
}

function createToast ({ Vue, message, propsData, onClose}) {
  const Constructor = Vue.extend(Toast);
  const toast = new Constructor({
    propsData
  })
  toast.$slots.default = message;
  toast.$mount()
  toast.$on('close', onClose)
  document.body.appendChild(toast.$el);
  return toast;
}

// toast.vue
// 主要关注点在于点击关闭后的清除dom操作
close() {
  // 清除元素
  this.$el.remove();
  this,$emit('close');
  // 销毁实例
  this.$destroy();
}

```

### 9. Tabs组件
核心思路：
> 采用最经典的发布订阅模式，引入了eventBus，因为只要某一项被激活需要通知其他兄弟组件的此时的选中状态。

```js
// tabs.vue 注入eventBus
<div class="koma-tabs">
  <slot></slot>
</div>

export default {
  props: {
    selected: {
      type: String,
      required: true
    }
  }, 
  data() {
    return {
      eventBus: new Vue,
    }
  },
  provide() {
    return {
      eventBus: this.eventBus
    }
  },
  mounted() {
    this.eventBus && this.eventBus.$emit('update:selected', this.selected)
  }
}
```

```js
// tabs-head.vue
<template>
  <div ref="tabsHead" class="koma-tabs-head">
    <!-- 独立line出来是为了做动画 -->
    <div ref="activeLine" class="active-line"></div>
    <slot></slot>
  </div>
</template>

export default {
  inject: [ 'eventBus' ],
  mounted() {
    if(this.eventBus) {
      this.eventBus.$on('update:selected', (name)=>{
        this.$children.forEach((vm) => {
          if(vm.name === name) {
            const { width } = vm.$el.getBoundingClientRect()
            // 注意这里使用的是offsetLeft， 而不是left，因为line相对parent定位的所以获取相对parent的left值
            const left = vm.$el.offsetLeft
            this.$ref['activeLine'].style.width = width
            this.$ref['activeLine'].style.left = left
          }
        })
      })
    }
  },
}
```


```js
// tabs-item.vue 
// 负责发布 点击事件后的name
<template>
  <div class="koma-tabs-item" @click="onClick" :class="{ active }"></div>
</template>


export default {
  props: {
    name: {
      type: String | Number,
      required: true
    }
  },
  data() {
    return {
      active: new Vue,
    }
  },
  inject: [ 'eventBus' ],
  mounted() {
    if(this.evnentBus) {
      this.eventBus.$on('update:selected', (name) => {
        this.active = name === this.name
      })
    }
  },
  methods: {
    onclick() {
      this.eventBus && this.eventBus.$emit('update:selected', this.name)
    }
  }
}
```

### 10. Popover组件
核心思路：
> popover组件实现起来有点麻烦，但是核心思路还是很简单，在组件内部预备两个插槽，一个是trigger触发器（这也是默认插槽），另外一个是 content 内容插槽。通过监听触发器的click或hover事件，触发content的显示。 
> 显示：content的显示需要重新定位，因为放在popover下面的话，如果父容器 `overflow：hidden; ` ，也会导致content显示问题。所以content visible时，如果用户传入指定挂载容器就挂载至改容器下，没有的话就直接挂载到body下。
> 隐藏：content的隐藏，需要监听document的点击事件，当点击popover或者content的时候都是不需要隐藏的，所以触发关闭条件时需要排除掉点击这些时的情况。

```js
<template>
  <div class="koma-popover" ref="popover">
    <div ref="contentWrapper" class="koma-popover-content-wrapper" v-if="visible"
      :class="{[`position-${position}`]:true}">
      <slot name="content" :close="close"></slot>
    </div>
    <span ref="triggerWrapper" style="display: inline-block;">
      <slot></slot>
    </span>
  </div>
</template>

export default {
  name: 'KomaPopover',
  props: {
    position: {
      type: String,
      default: 'top',
      validator(val){
        return ['top', 'bottom', 'left', 'right'].indexOf(val) >= 0
      }
    },
    trigger: {
      type: String,
      default: 'click',
      validator(val){
        return ['click', 'hover'].indexOf(val) >= 0
      }
    },
    container: {
      type: Element
    }
  },
  data() {
    return {
      visible: true,
    }
  },
  mounted() {
    // 为什么不直接在div里绑定click事件？
    // 因为这里支持两种click和mouseenter的方式，如果直接绑定在div上将无法区分
    this.addPopoverListener()
  },
  beforeDestroy() {
    this.recoverElcontent();
    this.removePopoverListener();
  },
  methods: {
    removePopoverListener() {
      let popoverEL = this.$refs.popover;
      if(!popoverEL) { return; }
      if(this.trigger === 'click') {
        popoverEl.removeEventListener('click', this.clickPopover)
      } else {
        popoverEl.removeEventListener('mouseenter', this.open)
        popoverEl.removeEventListener('mouseleave', this.close)
      }
    },
    addPopoverListener() {
      let popoverEl = this.$refs.popover
      if(this.popoverEl) {
        if(this.trigger === 'click') {
          popoverEl.addEventListener('click', this.clickPopover)
        } else {
          popoverEl.addEventListener('mouseenter', this.open)
          popoverEl.addEventListener('mouseleave', this.close)
        }
      }
    },
    recoverElcontent() {
      const {contentWrapper, popover} = this.$refs
      if(!contentWrapper){return}
      popover.appendChild(contentWrapper)
    },
    clickPopover(e) {
      if(this.$refs.triggerWrapper.contains(e.target)) {
        if(this.visible) {
          this.close()
        } else {
          this.open()
        }
      }
    },
    open() {
      this.visible = true
      // content显示后，记得给document绑定click事件，点击popover以外的地方都要关闭content
      document.addEventListener('click', this.listenToDocument)
      this.updatePopoverPosition()
    },
    close() {
      this.visible = false
      this.$emit('close')
      document.removeEventListener('click', this.listenToDocument)
    },
    updatePopoverPosition() {
      const { popover, triggerWrapper } = this.$refs;
      if(!popover){return;}
      // 需要先挂载到页面上，才能设样式
      (this.container || document.body).appendChild(popover)
      const { left, top, height, width } = triggerWrapper.getBoundingClientRect()
      const { height: height2 } = contentWrapper.getBoundingClientRect()

      let positions = {
        top: {
          top: top + window.scrollY,
          left: left + window.scrollX
        },
        bottom: {
          top: top + height + window.scrollY,
          left: left + window.scrollX,
        },
        left: {
          top: top + window.scrollY + (height - height2)/2,
          left: left + window.scrollX
        },
        right: {
          top: top + window.scrollY + (height - height2)/2,
          left: left + width + window.scrollX
        }
      }
      contentWrapper.style.left = positions[this.position].left + 'px'
      contentWrapper.style.top = positions[this.position].top + 'px';
    },
    listenToDocument(e) {
      if(this.$refs.popover === e.target || this.$refs.popover.contains(e.target)){
        return;
      }
      if(this.$refs.triggerWrapper === e.target || this.$refs.triggerWrapper.contains(e.target)){
        return;
      }
      this.close()
    },

  }
  
}
```